#!/bin/env python

from ConfigParser import SafeConfigParser
import datetime
from optparse import OptionParser
from os.path import expanduser
import re
import socket
import sys
import time

class usetrax:
  """
  usetrax - show resource usage info collected by the usetrax data base
            daemon (utdb)

  usetrax [-h -v] [--config=path] [--end=time] [--resource=str]
          [--server=str] [--start=time] [--step=int] [--sum=str]

  Options:

    -h
      Show this information, then exit

    -v
      Print version, then exit

    --config=path
      Path to usetrax config file.  Defaults to ~/.usetrax.

    Other command-line options correspond to the configuration file
    options listed below.  If an option appears both on the command line
    and in the config file, the command line value takes precedence.

  Configuration options for usetrax are in section [usetrax].
  Config file options:

    end: time
      The end of the time range to display; defaults to the current time.
      The time specification may be given as an integer (seconds since epoch),
      a string of the format "-nn[smhd]" (number of seconds/minutes/hours/days
      before the current time, defaults to minutes), or a date/time string of
      the format "YYYY-MM-DD:HH:MM[:SS]".

    resource: str
      The name of the resource to report.  Defaults to '*'.

    server: str
      Contact information for the utdb daemon; format host[:port].

    start: time
      The beginning of the time range to display; defaults to 0.  See --end
      for time format.

    step: int
      Summarize usage information every int seconds throughout the start/end
      range.  Summarizes the entire range by default.

    sum: str
      Sum usage information by a resource attribute.  Curently supports
      attributes "job" and "user".
  """

  VERSION = '1.0'

  def __init__(self):

    # Parse options and store into self
    parser = OptionParser(
      add_help_option=False, version="%prog " + str(self.__class__.VERSION)
    )
    parser.add_option('-h', action='store_true')
    parser.add_option('-v', action='store_true')
    parser.add_option('--config', type='string')
    parser.add_option('--end', type='string')
    parser.add_option('--resource', type='string')
    parser.add_option('--server', type='string')
    parser.add_option('--start', type='string')
    parser.add_option('--step', type='int')
    parser.add_option('--sum', type='string')

    (options, args) = parser.parse_args()
    if options.h:
      help(self.__class__)
      sys.exit(0)
    if options.v:
      parser.print_version()
      sys.exit(1)

    self.config = expanduser('~') + '/.usetrax'
    if options.config:
      self.config = options.config

    self.end = int(time.time())
    self.resource = '*'
    self.server = 'localhost:7734'
    self.start = 0
    self.step = None
    self.sum_by = None

    parser = SafeConfigParser()
    parser.read(self.config)

    if options.end:
      self.end = self.parse_time(options.end)
    elif parser.has_option('usetrax', 'end'):
      self.end = self.parse_time(parser.get('usetrax', 'end'))
    if options.resource:
      self.resource = options.resource
    elif parser.has_option('usetrax', 'resource'):
      self.resource = parser.get('usetrax', 'resource')
    if options.server:
      self.server = options.server
    elif parser.has_option('usetrax', 'server'):
      self.server = parser.get('usetrax', 'server')
    if options.start:
      self.start = self.parse_time(options.start)
    elif parser.has_option('usetrax', 'start'):
      self.start = self.parse_time(parser.get('usetrax', 'start'))
    if options.step:
      self.step = int(options.step)
    elif parser.has_option('usetrax', 'step'):
      self.step = parser.getint('usetrax', 'step')
    if options.sum:
      self.sum_by = options.sum
    elif parser.has_option('usetrax', 'sum'):
      self.sum_by = parser.get('usetrax', 'sum')

    # Open a connection to the usetrax daemon
    (addr, port) = (self.server, 7734)
    if self.server.find(':') >= 0:
      (addr, port) = self.server.split(':', 1)
    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.server_socket.connect((addr, int(port)))

    # Get host and sum-by information for all IPs--quicker than retrieving
    # it individually for those IPs we care about.
    host_ips = { }
    ip_hosts = { }
    ip_sum_by = { }
    # GET inefficient, so use HISTORY even for host attr
    # HISTORY reply format "OK [server,ip,attr,timestamp,value]..."
    self.send("HISTORY * * %s host" % self.end)
    reply = self.recv()
    if reply.startswith('OK ['):
      for item in reply[4:len(reply) - 1].split(']['):
        (server,ip,attr,timestamp,value) = item.split(',')
        ip_hosts[ip] = value
        host_ips[value] = ip
    if self.sum_by:
      self.send("HISTORY * * 0-%s %s" % (self.end, self.sum_by))
      reply = self.recv()
      if reply.startswith('OK ['):
        for item in reply[4:len(reply) - 1].split(']['):
          (server,ip,attr,timestamp,value) = item.split(',')
          timestamp = int(timestamp)
          if host_ips.has_key(ip):
            # Sum-by value mapped to hostname; switch to IP
            ip = host_ips.get(ip)
          if not ip_sum_by.has_key(ip):
            ip_sum_by[ip] = []
          ip_sum_by[ip].append((timestamp, "%s=%s" % (self.sum_by, value)))

    # foreach time step ...
    if not self.step:
      self.step = self.end - self.start + 1
    for timestep in range(self.start, self.end, self.step):
      end_step = timestep + self.step - 1
      usage_this_step = { }
      self.send("HISTORY %s * %s-%s *" % (self.resource, timestep, end_step))
      reply = self.recv()
      if reply.startswith('OK ['):
        # foreach server/ip/attr/timestamp/value tuple from this time step ...
        for value in reply[4:len(reply) - 1].split(']['):
          (server, ip, attr, timestamp, value) = value.split(',')
          timestamp = int(timestamp)
          # Determine "user".  If we're summing job/user and we have a summary
          # attribute for this IP, use that; otherwise, if we have a host name
          # for the IP, use that; otherwise, IP
          if ip_sum_by.has_key(ip) and timestamp >= ip_sum_by[ip][0][0]:
            # Pop older values of ip_sum_by for this IP
            while len(ip_sum_by[ip]) > 1 and timestamp >= ip_sum_by[ip][1][0]:
              ip_sum_by[ip].pop(0)
            user = ip_sum_by[ip][0][1]
          elif ip_hosts.has_key(ip):
            user = ip_hosts[ip]
          else:
            user = ip
          # Add to attribute summary for this "user"
          if not usage_this_step.has_key(user):
            usage_this_step[user] = { }
          if not usage_this_step[user].has_key(attr):
            usage_this_step[user][attr] = 0
          usage_this_step[user][attr] += int(float(value))
          # Compute 'total' values that sum per-user reads and writes
          if attr.startswith('read') or attr.startswith('write'):
            totalattr = attr.replace('read', 'total').replace('write', 'total')
            if not usage_this_step[user].has_key(totalattr):
              usage_this_step[user][totalattr] = 0
            usage_this_step[user][totalattr] += int(float(value))

      for user in sorted(usage_this_step.keys()):
        display = "%s %s " % (timestep, user)
        for attr in sorted(usage_this_step[user].keys()):
          display += ' %s %s' % (attr, usage_this_step[user][attr])
        print display
        sys.stdout.flush()

  def parse_time(self, s):
    """
    Parses the time specification given with the --start and --end command-line
    options.  Returns the specified time in seconds since the epoch.
    """
    result = int(time.time())
    if re.match('^\d+$', s):
      result = int(s)
    elif re.match('^-\d+[dDhHmMsS]?$', s):
      match_info = re.match('^-(\d+)([dDhHmMsS]?)$', s)
      bump = int(match_info.group(1))
      ch = 'm'
      if match_info.group(2):
        ch = match_info.group(2).lower()
      if ch == 'd':
        result -= bump * 24 * 60 * 60
      elif ch == 'h':
        result -= bump * 60 * 60
      elif ch == 's':
        result -= bump
      else:
        result -= bump * 60
    elif re.match('^\d\d\d\d-\d\d-\d\d:\d\d', s):
      match_info = re.match('^(\d+)-(\d+)-(\d+):(\d+)(:(\d+))?', s)
      minute = 0
      if match_info.group(6) != None:
        minute = int(match_info.group(6))
      dt = datetime.datetime(year = int(match_info.group(1)),
                             month = int(match_info.group(2)),
                             day = int(match_info.group(3)),
                             hour = int(match_info.group(4)),
                             minute = minute)
      result = int(time.mktime(dt.timetuple()))
    else:
      pass
    return result

  def recv(self):
    """
    A convenience method for receiving a message from the usetrax daemon.
    """
    result = ''
    while not result.endswith("\n"):
      chunk = self.server_socket.recv(2560)
      if chunk == '':
        result = None
        break
      result += chunk
    if not result:
      sys.stderr.write('usetrax daemon closed connection\n')
      sys.exit(1)
    elif not result.startswith('OK '):
      sys.stderr.write('Garbled message "%s" from usetrax daemon\n' % result)
      sys.exit(1)
    return result.strip()

  def send(self, message):
    """
    A convenience method for sending a message to the usetrax daemon.
    """
    self.server_socket.send(message + "\n")

usetrax()
