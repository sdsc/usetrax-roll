#!/bin/env python

from optparse import OptionParser
import commands
import os
import re
import socket
import sys
import time

class usetraxjobmon:
  """
  usetraxjobmon - batch job monitor daemon for usetrax

  usetraxjobmon [-h -v] [--log=path] [--pause=int] [--resource=str]
                [--server=str] &

  This program parses the output of qstat to send batch job information
  to a usetrax data base daemon.

  Options:

    -h
      Show this information, then exit

    -v
      Print version, then exit

    --log=path
      Path to monitor log file.   Defaults to "usetraxjobmon.log".

    --pause=int
      The number of seconds to sleep between monitoring.  Defaults to 300.

    --resource=str
      The name of the resource being monitored.  Default is derived from
      the host name.

    --server=str
      Contact information for the usetrax daemon; format host[:port].
      Defaults to sending messages only to log file.
  """

  VERSION = '1.0'

  def __init__(self):

    # Parse options and store into self
    parser = OptionParser(
      add_help_option=False, version="%prog " + str(self.__class__.VERSION)
    )
    parser.add_option('-h', action='store_true')
    parser.add_option('-v', action='store_true')
    parser.add_option('--log', type='string')
    parser.add_option('--pause', type='int')
    parser.add_option('--resource', type='string')
    parser.add_option('--server', type='string')

    (options, args) = parser.parse_args()
    if options.h:
      help(self.__class__)
      sys.exit(0)
    if options.v:
      parser.print_version()
      sys.exit(1)

    self.logpath = 'usetraxjobmon.log'
    if options.log:
      self.logpath = options.log
    self.pause = 300
    if options.pause != None:
      self.pause = options.pause
    self.resource = re.split('[-\.]', commands.getoutput('/bin/hostname'))[0]
    if options.resource:
      self.resource = options.resource
    self.server = None
    if options.server:
      self.server = options.server

    # Open a connection to the usetrax daemon
    self.serverSocket = None
    if self.server:
      self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      (addr, port) = (self.server, 7734)
      if self.server.find(':') >= 0:
        (addr, port) = self.server.split(':', 1)
      self.serverSocket.connect((addr, int(port)))

    # Close stdin
    sys.stdin.close()
    os.close(0)

    host_jobs_reported = { }
    host_users_reported = { }

    while 1:

      now = int(time.time())
      self.logfile = open(self.logpath, 'a+')

      for line in commands.getoutput('qstat -n1').split("\n"):

        pieces = re.split('\s+', line)
      
        if len(pieces) < 10 or pieces[9] != 'R':
          # Not a running job
          continue
        match_info = re.search('^(\d+)', pieces[0])
        if not match_info:
          self.log("Bad qstat line format '%s'" % line)
          continue

        job = "%s-%s" % (match_info.group(1), self.resource)
        hosts = pieces[-1]
        user = pieces[1]

        for host in re.split('\+', hosts):
          host = host.split('/', 1)[0]
          if not host_jobs_reported.has_key(host) or \
             host_jobs_reported[host] != job:
            message = "SET %s %s %s job %s" % (self.resource, host, now, job)
            self.report(message)
            host_jobs_reported[host] = job
          if not host_users_reported.has_key(host) or \
             host_users_reported[host] != user:
            message = "SET %s %s %s user %s" % (self.resource, host, now, user)
            self.report(message)
            host_users_reported[host] = user

      self.logfile.close()
      time.sleep(self.pause)

  def log(self, message):
    """
    TODO
    """
    if self.logfile:
      self.logfile.write(message + "\n")

  def report(self, message):
    """
    TODO
    """
    if self.serverSocket:
      self.serverSocket.send(message + "\n")
      # Receive and discard ack
      self.serverSocket.recv(256)
    self.log(message)

usetraxjobmon()
